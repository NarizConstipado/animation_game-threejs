<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    body {
			/* set margin to 0 and overflow to hidden, to use the complete page */
			margin: 0;
			overflow: hidden;
		}
</style>

<body>
    <script type="module">
        import Tree from './treeClass.js';
        import Kirby from './kirbyClass.js'; 
        import * as THREE from './libs/three.module.js';
        import * as CONTROLS from './libs/OrbitControls.js';
        import * as BufferGeometryUtils from './libs/BufferGeometryUtils.js';
        import { LineSegments2 } from './libs/lines/LineSegments2.js';
        import { LineSegmentsGeometry } from './libs/lines/LineSegmentsGeometry.js';
        import { LineMaterial } from './libs/lines/LineMaterial.js';

        //map
        let clicked_keys = []
        let collisionsWalls = [];
        let treesColection = []
        let oldPosition, oldRotation
        let kirby
        
        //trees
        let tree
        
        //junk
        

        //other
        let camera, scene, renderer;
        let bbHelper, bbHelper1, bbHelper2, bbHelper3, bbHelper4, bbtreeTronk
        let controls

        window.onload = () => {
            scene = new THREE.Scene();

        //camera
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 600);
            camera.position.y = 15;
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ antilias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);

            renderer.setClearColor("#000000");
            document.body.appendChild(renderer.domElement);
            
            controls = new CONTROLS.OrbitControls(camera, renderer.domElement)
            
        //KIRBY
            kirby = new Kirby()

        //TREE
            let scale = {x: 2.5, y: 2.5, z: 2.5}
            tree = new Tree(0,0,scale, 0.5, 1)
            collisionsWalls.push(tree.treeTronk)
            treesColection.push(tree)
            treesColection.forEach(tree => {
                scene.add(tree.pivot)
            })
            const axes = new THREE.AxesHelper();
            tree.treeTronk.add(axes)
        //map
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), new THREE.MeshBasicMaterial({ color: 0x60ee60 }))
            floor.rotation.x = -Math.PI / 2
            floor.position.y = -1.1
            
            let wallSideRight = new THREE.Mesh(new THREE.PlaneGeometry(50, 40), new THREE.MeshBasicMaterial({color: 0x20ee00}))
            wallSideRight.position.set(25,18,0)
            wallSideRight.rotation.y = -Math.PI / 2
            collisionsWalls.push(wallSideRight)
            
            let wallSideLeft = new THREE.Mesh(new THREE.PlaneGeometry(50, 40), new THREE.MeshBasicMaterial({color: 0x20ee00}))
            wallSideLeft.position.set(-25,18,0)
            wallSideLeft.rotation.y = Math.PI / 2
            collisionsWalls.push(wallSideLeft)
            
            let wallFront = new THREE.Mesh(new THREE.PlaneGeometry(50, 40), new THREE.MeshBasicMaterial({color: 0x20ee00}))
            wallFront.position.set(0,18,-25)
            collisionsWalls.push(wallFront)
            
            
            let wallBack = new THREE.Mesh(new THREE.PlaneGeometry(50, 20), new THREE.MeshBasicMaterial({color: 0x20ee00}))
            wallBack.position.set(0,8,25)
            wallBack.rotation.y = -Math.PI
            collisionsWalls.push(wallBack)

            /* const axes = new THREE.AxesHelper(10);
            wallSideLeft.add(axes) */
            
            const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1)
            light.position.set(0, 3, 3)
            
            //*************************** KIRBY 2 ***************************
            let kirby2 = new Kirby(0xffffff, true, false)
            kirby2.position_default()
            kirby2.character.rotation.y = Math.PI / 4
            scene.add(kirby2.character)
            //************************ FINAL KIRBY 2 ************************

            scene.add(wallFront, wallBack, wallSideRight, wallSideLeft, floor, light, kirby.character)
            
            kirby.position_default()
            kirby.body.geometry.computeBoundingBox();
            wallFront.geometry.computeBoundingBox();
            wallBack.geometry.computeBoundingBox();
            wallSideLeft.geometry.computeBoundingBox();
            wallSideRight.geometry.computeBoundingBox();
            treesColection.forEach(tree => {
                tree.treeTronk.geometry.computeBoundingBox();
            })

            bbHelper = new THREE.BoxHelper(kirby.body, 0x00FFFF);
            bbHelper1 = new THREE.BoxHelper(wallFront, 0x00FFFF);
            bbHelper2 = new THREE.BoxHelper(wallBack, 0x00FFFF);
            bbHelper3 = new THREE.BoxHelper(wallSideLeft, 0x00FFFF);
            bbHelper4 = new THREE.BoxHelper(wallSideRight, 0x00FFFF);
            bbtreeTronk = new THREE.BoxHelper(tree.treeTronk, 0x00FFFF);
            bbtreeTronk.position.set(tree.pivot.position)
            scene.add(bbHelper, bbHelper1, bbHelper2, bbHelper3, bbHelper4, bbtreeTronk);

        //renderer
            renderer.setAnimationLoop(render);
        }

        function render() {
            renderer.render(scene, camera)
            bbHelper.update()
            treesColection.forEach(tree => {
                tree.animationsTree()
            })
            
            camera.lookAt(kirby.character.position)

            kirby.tornado.rotation.z -= Math.PI / 100 
        
            oldPosition = {x: kirby.character.position.x, z: kirby.character.position.z} 
            oldRotation = kirby.character.rotation.y
            
            kirby.walk(clicked_keys)
            
            /* if(checkCollisions()){
                kirby.character.rotation.y = oldRotation
                if(kirby.character.position.x < 0) kirby.character.position.x = oldPosition.x + 0.5
                else kirby.character.position.x = oldPosition.x -0.1
                if(kirby.character.position.z < 0) kirby.character.position.z = oldPosition.z + 0.5
                else kirby.character.position.z = oldPosition.z -0.1
            }    */         
        }

    //collisions detector
        function checkCollisions(){
            let Bkirby = new THREE.Box3().setFromObject(kirby.body);
			for (let i = 0; i < collisionsWalls.length; i++) {
				let obstBox = new THREE.Box3().setFromObject(collisionsWalls[i]);
				let collision = Bkirby.intersectsBox(obstBox);
				if (collision) {
					console.log("HIT")
					return true;
				} 
			}
            return false;
        };

    //kirby section
        // ANIMATION ACTIVATE
        document.addEventListener('keypress', (e) => {
            if (!clicked_keys.includes(e.key.toLowerCase())) clicked_keys.push(e.key.toLowerCase())
        })

        document.addEventListener('keyup', (e) => {
            clicked_keys.splice(clicked_keys.indexOf(e.key), 1)
            if (!clicked_keys.includes("e")) kirby.position_default()
        })
    </script>
</body>

</html>