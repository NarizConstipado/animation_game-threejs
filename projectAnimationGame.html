<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    body {
			/* set margin to 0 and overflow to hidden, to use the complete page */
			margin: 0;
			overflow: hidden;
		}
</style>

<body>
    <script type="module">
        import Spider from './spiderClass.js';
        import PaperBall from './paper_ballClass.js';
        import DragonFly from './dragonFlyClass.js';
        import Frog from './frog.js';
        import Tree from './treeClass.js';
        import Kirby from './kirbyClass.js'; 
        import * as THREE from './libs/three.module.js';
        import * as CONTROLS from './libs/OrbitControls.js';
        import * as BufferGeometryUtils from './libs/BufferGeometryUtils.js';
        import { LineSegments2 } from './libs/lines/LineSegments2.js';
        import { LineSegmentsGeometry } from './libs/lines/LineSegmentsGeometry.js';
        import { LineMaterial } from './libs/lines/LineMaterial.js';

        //map
        let clicked_keys = []
        let collisionsWalls = [];
        let treesColection = [], trashColection = []
        let oldPosition, oldRotation
        let kirby
        
        //trees
        let tree, tree2, tree3, tree4, tree5, tree6, tree7, tree8, tree9, tree10
        
        //junk
        let dragonFly, paperBall, spider, frog
        let rotationBody, allowRotation = false

        //other
        let camera, scene, renderer;
        let bbHelper, bbHelper1, bbHelper2, bbHelper3, bbHelper4, bbtreeTronk
        let controls

        window.onload = () => {
            scene = new THREE.Scene();

        //camera
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 600);
            camera.position.y = 15;
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ antilias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);

            renderer.setClearColor("#000000");
            document.body.appendChild(renderer.domElement);
            
            controls = new CONTROLS.OrbitControls(camera, renderer.domElement)
            
        //KIRBY
            kirby = new Kirby()

        //trashItems
        //dragonFly
        let scaleDragon = {x: 0.4,y: 0.4,z: 0.4}
        let positionDragon = {x: 10,y: 10,z: 0}
        let rotationDragon = {x: 0,y: 0,z: 0}
        let velocityDragon = 1
        dragonFly = new DragonFly(positionDragon, scaleDragon, rotationDragon, velocityDragon)
        trashColection.push(dragonFly)
        
        
        //paperBall
        let scaleBall = {x: 0.4,y: 0.4,z: 0.4}
        let positionBall = {x: 2.6,y: 10,z: 23}
        let rotationBall = {x: 0,y: 0,z: 0}
        let velocityBall = 1
        paperBall = new PaperBall(positionBall, scaleBall, rotationBall, velocityBall)
        trashColection.push(paperBall)
        //spider
        /* let scaleSpider = {x: 0.4,y: 0.4,z: 0.4}
        let positionSpider = {x: -5,y: 10,z: 5}
        let rotationSpider = {x: 0,y: 0,z: 0}
        let velocitySpider = 1
        spider = new Spider(positionSpider, scaleSpider, rotationSpider, velocityBall)
        trashColection.push(spider) */

        trashColection.forEach(trash => scene.add(trash.body))
        
            
        //TREES
            let scaleTree = {x: 2.5, y: 2.5, z: 2.5}
            let positionTree = {x: 0, y: -1.1, z: -10}
            tree = new Tree(positionTree,scaleTree, 0.5, 1, dragonFly)
            treesColection.push(tree)

            let scaleTree2 = {x: 2, y: 2, z: 2}
            let positionTree2 = {x: 8, y: -1.5, z: -12}
            tree2 = new Tree(positionTree2,scaleTree2, 3.5, 2)
            treesColection.push(tree2)
            
            let scaleTree3 = {x: 2, y: 2, z: 2}
            let positionTree3 = {x: -3, y: -1.1, z: 18}
            tree3 = new Tree(positionTree3,scaleTree3, 5, 1.5)
            treesColection.push(tree3)
            
            let scaleTree4 = {x: 3.5, y: 3.5, z: 3.5}
            let positionTree4 = {x: -15, y: -1.1, z: 0}
            tree4 = new Tree(positionTree4,scaleTree4, -0.3, 0.5)
            treesColection.push(tree4)

            let scaleTree5 = {x: 3, y: 3, z: 3}
            let positionTree5 = {x: -7, y: -1.1, z: -15}
            tree5 = new Tree(positionTree5,scaleTree5, 0.5, 1)
            treesColection.push(tree5)
            
            let scaleTree6 = {x: 2.7, y: 2.7, z: 2.7}
            let positionTree6 = {x: 10, y: -1.1, z: 10}
            tree6 = new Tree(positionTree6,scaleTree6, 0.5, 1)
            treesColection.push(tree6)
            
            let scaleTree7 = {x: 4.5, y: 4.5, z: 4.5}
            let positionTree7 = {x: 17, y: -1.1, z: -17}
            tree7 = new Tree(positionTree7,scaleTree7, 3, 1)
            treesColection.push(tree7)
            
            let scaleTree8 = {x: 5, y: 5, z: 5}
            let positionTree8 = {x: 20, y: -1.1, z: 13}
            tree8 = new Tree(positionTree8,scaleTree8, 5, 1)
            treesColection.push(tree8)
            
            let scaleTree9 = {x: 3, y: 3, z: 3}
            let positionTree9 = {x: -17, y: -1.1, z: 17}
            tree9 = new Tree(positionTree9,scaleTree9, 2, 1)
            treesColection.push(tree9)
            
            let scaleTree10 = {x: 3.5, y: 3.5, z: 3.5}
            let positionTree10 = {x: 8, y: -1.1, z: 23}
            tree10 = new Tree(positionTree10,scaleTree10, 6, 1, paperBall)
            treesColection.push(tree10)
            /* collisionsWalls.push(tree.treeTronk) */
            treesColection.forEach(tree => {
                scene.add(tree.pivot)
            })
        //map
            const floor = new THREE.Mesh(new THREE.CircleGeometry(30, 64), new THREE.MeshBasicMaterial({ color: 0x60ee60 }))
            floor.rotation.x = -Math.PI / 2
            floor.position.y = -1.1
            
            /* let wallSideRight = new THREE.Mesh(new THREE.PlaneGeometry(50, 40), new THREE.MeshBasicMaterial({color: 0x20ee00}))
            wallSideRight.position.set(25,18,0)
            wallSideRight.rotation.y = -Math.PI / 2
            collisionsWalls.push(wallSideRight)
            
            let wallSideLeft = new THREE.Mesh(new THREE.PlaneGeometry(50, 40), new THREE.MeshBasicMaterial({color: 0x20ee00}))
            wallSideLeft.position.set(-25,18,0)
            wallSideLeft.rotation.y = Math.PI / 2
            collisionsWalls.push(wallSideLeft)
            
            let wallFront = new THREE.Mesh(new THREE.PlaneGeometry(50, 40), new THREE.MeshBasicMaterial({color: 0x20ee00}))
            wallFront.position.set(0,18,-25)
            collisionsWalls.push(wallFront)
            
            
            let wallBack = new THREE.Mesh(new THREE.PlaneGeometry(50, 20), new THREE.MeshBasicMaterial({color: 0x20ee00}))
            wallBack.position.set(0,8,25)
            wallBack.rotation.y = -Math.PI
            collisionsWalls.push(wallBack) */

            /* const axes = new THREE.AxesHelper(10);
            wallSideLeft.add(axes) */
            
            const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1)
            light.position.set(0, 3, 3)
            
            scene.add(floor, light, kirby.character/* wallFront, wallBack, wallSideRight, wallSideLeft,  */)
            
            kirby.position_default()
            bbHelper = new THREE.BoxHelper(tree10.pivot, 0x00FFFF);
            scene.add(bbHelper)
            /* 
            kirby.body.geometry.computeBoundingBox();
            wallFront.geometry.computeBoundingBox();
            wallBack.geometry.computeBoundingBox();
            wallSideLeft.geometry.computeBoundingBox();
            wallSideRight.geometry.computeBoundingBox();
            treesColection.forEach(tree => {
                tree.treeTronk.geometry.computeBoundingBox();
            })

            bbHelper1 = new THREE.BoxHelper(wallFront, 0x00FFFF);
            bbHelper2 = new THREE.BoxHelper(wallBack, 0x00FFFF);
            bbHelper3 = new THREE.BoxHelper(wallSideLeft, 0x00FFFF);
            bbHelper4 = new THREE.BoxHelper(wallSideRight, 0x00FFFF);
            bbtreeTronk = new THREE.BoxHelper(tree.treeTronk, 0x00FFFF);
            bbtreeTronk.position.set(tree.pivot.position)
            scene.add(bbHelper, bbHelper1, bbHelper2, bbHelper3, bbHelper4, bbtreeTronk); */

        //renderer
            renderer.setAnimationLoop(render);
        }

        function render() {
            renderer.render(scene, camera)
            bbHelper.update()

            //treeAnimations
            treesColection.forEach(tree => {
                tree.animationsTree()
            })
            //trashAnimations
            //animationTrashFall(paperBall)
            
            trashColection.forEach(trash => {
                if(trash.animationStart == true){
                    trash.animation()
                }
            })

            
            camera.lookAt(kirby.character.position)

            kirby.tornado.rotation.z -= Math.PI / 100 
        
            oldPosition = {x: kirby.character.position.x, z: kirby.character.position.z} 
            oldRotation = kirby.character.rotation.y
            kirby.walk(clicked_keys)
            
            /*if(checkCollisionsTree()){
            }            
             kirby.character.rotation.y = oldRotation
            kirby.character.position.x = oldPosition.x
            kirby.character.position.z = oldPosition.z
            if(Math.sign(kirby.character.position.x) == -1) kirby.character.position.x = oldPosition.x + 0.5
            else kirby.character.position.x = oldPosition.x -0.5
            if(Math.sign(kirby.character.position.z) == -1) kirby.character.position.z = oldPosition.z + 0.5
            else kirby.character.position.z = oldPosition.z -0.5 */
        }

    //collisions detector

        function checkCollisionsTree(){
            let Bkirby = new THREE.Box3().setFromObject(kirby.body);
            for (let i = 0; i < treesColection.length; i++) {
                let obstBox = new THREE.Box3().setFromObject(treesColection[i].pivot);
                let collision = Bkirby.intersectsBox(obstBox);
                if (collision) {
                    console.log("HIT")
                    return treesColection[i];
                } 
            }
            return false;
        }
    
    //animationTrash fall
        function animationTrashFall(trash){
            if(trash.animationFall){
                trash.body.position.y -= 0.1
                if(trash.body.position.y <= -0.4) trash.animationFall = false; rotationBody = (Math.random() * 360)*Math.PI / 180, allowRotation = true
            } else {
                //insert collision check here
                if(allowRotation) {
                    if(trash.body.rotation.y <= rotationBody) {
                        trash.body.rotation.y += 0.1 
                        if(trash.body.rotation.y >= rotationBody) allowRotation = false
                    } else {
                        trash.body.rotation.y -= 0.1
                        if(trash.body.rotation.y <= rotationBody) allowRotation = false
                    }
                } else {
                    trash.animationStart = true
                    trash.body.position.z -= -Math.cos(trash.body.rotation.y) * 0.1 * trash.velocity/2
                    trash.body.position.x -= -Math.sin(trash.body.rotation.y) * 0.1 * trash.velocity/2
                }
                
                
            }
        }
    //kirby section
        // ANIMATION ACTIVATE
        document.addEventListener('keypress', (e) => {
            if (!clicked_keys.includes(e.key.toLowerCase())) clicked_keys.push(e.key.toLowerCase())
        })

        document.addEventListener('keyup', (e) => {
            clicked_keys.splice(clicked_keys.indexOf(e.key), 1)
            if (!clicked_keys.includes("e")) kirby.position_default()
        })
    </script>
</body>

</html>